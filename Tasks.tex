% ! Chapter 3
% !     Section 2 - Waffle

% //---------------------------------------------------------------------------

% Tasks: Proposed solution
% -T1: Explain the way AFL works
% -T2: Explain an overview of the additional properties added to AFL by Waffle
% Keywords 
% -K1: NP-Hard problem
% -K2: exploration vs exploitation
% -K3: performance-guided fuzzing vs coverage-guided fuzzing

% //---------------------------------------------------------------------------

% Tasks
% -T: Explain the waffle-proc.png

% //---------------------------------------------------------------------------

% Tasks: Modified instrumentation
% -T1: Explain an overview of the modifications on AFL, no need to go deep
% -T2: Instrumentation stage

% //---------------------------------------------------------------------------

% Tasks: Modified fuzzing
% -T1: Explain an overview of the modifications on AFL, no need to go deep
% -T2: Fuzzing stage

% //---------------------------------------------------------------------------

% Tasks
% -T: Talk about the remainder of this section

% //---------------------------------------------------------------------------

% Tasks
% -T1: Resource complexity
% -T2: Overall Resource Complexity

% //---------------------------------------------------------------------------

% Tasks
% -T1: Engaged instructions

% //---------------------------------------------------------------------------

% Tasks
% -T1: EI-ORC collection

% //---------------------------------------------------------------------------

% !     Subsection 1: Instrumentation

% //---------------------------------------------------------------------------

% Tasks
% -T1: Generally define and explain the added and modified modules in Instrumentation

% //---------------------------------------------------------------------------

% Tasks
% -T1: Explain the added array and it's usage
% Keywords
% -K: total_ORC, 4x space, storage

% //---------------------------------------------------------------------------

% Tasks
% -T1: Explain the "addition" module for storing the counts
% Keywords
% -K1: traceEnd function
% -K2: TORC, total_ORC

% //---------------------------------------------------------------------------

% Tasks:
% -T1: Explain LLVM visitor functions
% -T2: Explain the implementation of the visitor functions

% //---------------------------------------------------------------------------

% Tasks:
% -T1: Explain the procedure of the module pass

% //---------------------------------------------------------------------------

% Tasks:
% -T1: Explain how the data is stored, and what preprocessings are applied
% Keywords
% -K1: logarithm
% -K2: The number of instructions increases so fast, calculate an estimation

% //---------------------------------------------------------------------------

% Tasks:
% -T: how to apply the instrumentation using the new recipe

% //---------------------------------------------------------------------------

% !     Subsection 2: Fuzzing

% //---------------------------------------------------------------------------

% Tasks
% -T: Generally define and explain the added and modified modules in Fuzzing

% //---------------------------------------------------------------------------

% Tasks
% -T: Explain the snippets of the code

% //---------------------------------------------------------------------------

% Tasks
% -T: Explain why and how we implemented the Elite ORCs and Elite ORCCs

% //---------------------------------------------------------------------------

% Tasks
% -T: Explain the find_elite() function and snippets of code

% //---------------------------------------------------------------------------

% Tasks
% -T: Explain the update_bitmap_score() function and snippets of code

% //---------------------------------------------------------------------------

% Tasks
% -T: Explain the calculate_score() function and it's snippets of code

% //---------------------------------------------------------------------------

% Tasks
% -T: Explain other modifications 

% //---------------------------------------------------------------------------

% Tasks
% -T: Wrap up

% //---------------------------------------------------------------------------

% !     Subsection 3: Application

% //---------------------------------------------------------------------------

% Tasks
% -T: Explain the Quicksort problem

% //---------------------------------------------------------------------------

% Tasks
% -T1: Explain the code and it's time complexity of Quicksort

% //---------------------------------------------------------------------------

% Tasks
% -T: Investigate the instrumentation of QSort
% Keywords
% -Ks: reverse-engineering, radare2, binary analysis 

% //---------------------------------------------------------------------------

% Tasks
% -T: Discuss the performance of the instrumented program

% //---------------------------------------------------------------------------

% Tasks
% -T: Start fuzzing and explain the initial operations

% //---------------------------------------------------------------------------

% Tasks
% -T: Investigate the fuzzing procedure

% //---------------------------------------------------------------------------

% Tasks
% -T: Investigate the performance

% //---------------------------------------------------------------------------

% Tasks:
% -T: Concluding remarks

% //---------------------------------------------------------------------------

% ! Chapter 4

% //---------------------------------------------------------------------------
