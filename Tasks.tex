% ! Chapter 3
% !     Section 2 - Waffle

% ? //---------------------------------------------------------------------------
% ? Done
% Tasks: Proposed solution
% -T1: Explain the way AFL works
% -T2: Explain an overview of the additional properties added to AFL by Waffle
% Keywords
% -K1: NP-Hard problem
% -K2: exploration vs exploitation
% -K3: performance-guided fuzzing vs coverage-guided fuzzing

% ? //---------------------------------------------------------------------------

% ? Done
% Tasks
% -T: Explain the waffle-proc.png

% //---------------------------------------------------------------------------
% // Tasks
% // -T1: Explain an overview of the modifications on AFL, no need to go deep
% // -T2: Instrumentation stage

% // Waffle modifies the recipe for llvm-based instrumentation to collect the new execution features, as well as changing the fuzzing stage for exploiting this feature. Waffle analyzes each basic block, and inserts the new instructions beside the coverage instructions from AFL. The extracted information is stored in a new list of 64bit integers, while Waffle has the access to process the result in fuzzing. Later, in fuzz testing, Waffle performs additional calculations for saving interesting entries, and evaluating queue entries for new favarable characteristics. 

% // Tasks
% // -T1: Explain an overview of the modifications on AFL, no need to go deep
% // -T2: Fuzzing stage

% // Tasks
% // -T: Talk about the remainder of this section

% // The key observation for the methodology used in Waffle is that the static analysis and instrumentations collect the required features for evolutionary search techniques in finding inputs that demonstrate worst-case complexity of a test application in a domain-independent way. However, to enable Waffle to efficiently find such inputs, we need to carefully design effective guidance mechanisms to drive Waffle's input generation process. We redesign the evolutionary algorithm of AFL with customized guidance mechanisms that are tailored for finding inputs causing worst-case behavior.

% //Next, we will discuss the instrumentation and fuzzing phases of Waffle in more details. To understand the effectiveness of our approach, we first introduce resource complexity of a program and explain how Waffle pivots on this feature for guiding the input generation. After that, the instrumentation phase is extended for discussion, which results in generating an instrumentated binary. The binary file is then passed to the fuzzer, and the evaluation of the inputs takes effect during the fuzzing procedure.

% ? //=========================================================================

% Tasks
% -T1: Estimated Resource Usage

% ? //=========================================================================

% Tasks
% -T1: How waffle uses the ERU through entire fuzzing chain

% //---------------------------------------------------------------------------

% !     Subsection 1: Instrumentation

% ? //=========================================================================

% Tasks
% -T1: Generally define and explain the added and modified modules in Instrumentation

% //---------------------------------------------------------------------------

% // Tasks
% // -T1: Explain the added array and it's usage
% // Keywords
% // -K: total_ORC, 4x space, storage

% //---------------------------------------------------------------------------

% // Tasks
% // -T1: Explain the "addition" module for storing the counts
% // Keywords
% // -K1: traceEnd function
% // -K2: TORC, total_ORC

% //---------------------------------------------------------------------------

% Tasks:
% -T1: Explain LLVM visitor functions
% -T2: Explain the implementation of the visitor functions

% //---------------------------------------------------------------------------

% Tasks:
% -T1: Explain the procedure of the module pass

% //---------------------------------------------------------------------------

% Tasks:
% -T1: Explain how the data is stored, and what preprocessings are applied
% Keywords
% -K1: logarithm
% -K2: The number of instructions increases so fast, calculate an estimation

% //---------------------------------------------------------------------------

% Tasks:
% -T: how to apply the instrumentation using the new recipe

% //---------------------------------------------------------------------------

% !     Subsection 2: Fuzzing

% //---------------------------------------------------------------------------

% Tasks
% -T: Generally define and explain the added and modified modules in Fuzzing

% //---------------------------------------------------------------------------

% Tasks
% -T: Explain the snippets of the code

% //---------------------------------------------------------------------------

% Tasks
% -T: Explain why and how we implemented the Elite ORCs and Elite ORCCs

% //---------------------------------------------------------------------------

% Tasks
% -T: Explain the find_elite() function and snippets of code

% //---------------------------------------------------------------------------

% Tasks
% -T: Explain the update_bitmap_score() function and snippets of code

% //---------------------------------------------------------------------------

% Tasks
% -T: Explain the calculate_score() function and it's snippets of code

% //---------------------------------------------------------------------------

% Tasks
% -T: Explain other modifications 

% //---------------------------------------------------------------------------

% Tasks
% -T: Wrap up

% //---------------------------------------------------------------------------

% !     Subsection 3: Application

% //---------------------------------------------------------------------------

% Tasks
% -T: Explain the Quicksort problem

% //---------------------------------------------------------------------------

% Tasks
% -T1: Explain the code and it's time complexity of Quicksort

% //---------------------------------------------------------------------------

% Tasks
% -T: Investigate the instrumentation of QSort
% Keywords
% -Ks: reverse-engineering, radare2, binary analysis 

% //---------------------------------------------------------------------------

% Tasks
% -T: Discuss the performance of the instrumented program

% //---------------------------------------------------------------------------

% Tasks
% -T: Start fuzzing and explain the initial operations

% //---------------------------------------------------------------------------

% Tasks
% -T: Investigate the fuzzing procedure

% //---------------------------------------------------------------------------

% Tasks
% -T: Investigate the performance

% //---------------------------------------------------------------------------

% Tasks:
% -T: Concluding remarks

% //---------------------------------------------------------------------------

% ! Chapter 4

% //---------------------------------------------------------------------------
