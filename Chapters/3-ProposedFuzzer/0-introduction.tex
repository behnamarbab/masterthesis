\section{Problem Statement}

A time-consuming and recourse-consuming execution can be used for attacking a server. For instance, suppose that a server is using an API, and it also prevents an excessive number of requests to defend against attacks such as DoS or DDoS. In such a scenario, to attack the server, one may request the server to call heavy executions and put pressure on the server to respond to the requests. As a result, finding such executions may help with stopping the server from responding appropriately.

The performance-guided fuzzing technique utilizes the fuzzer to discover the worst-case complexities of a program. Memory-guided fuzzing targets data structures and memory usage in execution, revealing vulnerable memory consumptions. On the other hand, fuzzers such as SlowFuzz and PerfFuzz monitor the performance-related instructions to detect excessive CPU usages. Hence, the set of resources under investigation in each fuzzer does not include both CPU and Memory usages together. To investigate the resources which can get compromised for revealing hidden resource-usage vulnerabilities, we suggest two solutions:

\begin{enumerate}
    \item Parallel fuzzing: The corpus of the queued test cases contains the latest findings of a fuzzer. A coverage-based fuzzer seeks new code coverages, and eventually, the corpus evolves with coverage-guided inputs. In a performance-guided fuzzing, the inputs gradually produce fuzzed data which uses more resources. Concurrent fuzzing suggests that if the corpora of parallel fuzzers are shared with the rest of the fuzzers, the outcome is a corpus that tracks the guiding features of all fuzzers. This approach generates vulnerabilities guided by considering both coverage and performance measurements. The synchronization of the fuzzers is simplified in various state-of-the-art fuzzers; for instance, AFL-based and LibFuzzer-based fuzzers can communicate with each other using the provided APIs \cite{afl_par}.
    
    \item Waffle: The fuzzer integrates the coverage-based and performance-based fuzzing and generates inputs for exploiting these features.
\end{enumerate}
