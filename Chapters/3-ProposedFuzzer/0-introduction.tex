\section{Problem Statement}

A time consuming and recourse consuming execution can be used for attacking a server. For instance, suppose that a server is using an API and it also prevents excessive number of requests to defend against attacks such as DoS or DDoS. In such a scenario, to attack the server, one may request the server to call heavy executions and put pressure on server for responding the requests. As a result, finding such executions may help with stopping the server from responding appropriately.

Performance-guided fuzzing technique utilizes the fuzzer to discover the worst-case complexities of a program. Memory-guided fuzzing targets data structures and memory usage in execution, revealing vulnerable memory consumptions. On the other hand, fuzzers such as SlowFuzz and PerfFuzz monitor the performance-related instructions to detect excessive CPU-usages. Hence, the set of resources under investigation in each fuzzer does not include both CPU and Memory usages together. To investigate the resources which can get compromised for revealing hidden resource-usage vulnerabilities, we suggest two solutions:

\begin{enumerate}
    \item Parallel fuzzing: The corpus of the queued test cases contains the latest findings of a fuzzer. A coverage-based fuzzer seeks for new code coverages, and eventually, the corpus evolves with coverage-guided inputs. In a performance-guided fuzzing, the inputs gradually produce fuzzed data which use more resources. Concurrent fuzzing suggests that if the corpora of parallel fuzzers is shared with rest of the fuzzers, the outcome is a corpus which tracks guiding features of all fuzzers. This approach generates vulnerabilities guided by considering both coverage and performance measurements. The synchronization of the fuzzers is simplified in various state-of-the-art fuzzers; for instance, AFL-based and LibFuzzer-based fuzzers can communicate with each other using the provided APIs \cite{afl_par}.
    
    \item Waffle: Waffle is a whitebox performance-guided AFL-based fuzzer for guiding the corpus-generation based on coverage and performance features. Waffle stands for What An Amazing AFL (WAAAFL)! The introduced fuzzer is designed to collect the usages of any type of instruction in a run. Waffle can focus on a set of one or more instructions, and searches for the inputs which maximizes the occurrences of the targeted instructions. The coverage information derived from AFL remains the exploration methology of AFL, and the performance-guidance exploits the discovered regions by finding excessive resource usages.
\end{enumerate}
