\section{Instrumentation}
\label{sec:3-instr}

\subsubsection*{waffle-llvm-rt.o.c}

We initialize the instrumentation with setting up the shared memory for Waffle (Listing \ref{lst:llvm-rt}):

\lstinputlisting[language=C,style=CodeStyle,label={lst:llvm-rt},caption={LLVM instrumentation bootstrap}]{Codes/Chapter3/waffle-llvm-rt.o.c}

\texttt{\_\_wafl\_area\_ptr} is the region that is allocated for counting the instructions, and is later shared when the instrumented program is running in fuzz testing.

The size of the bitmap \texttt{\_\_wafl\_icnt\_ptr} is equal to $ICNT\_SIZE=2^{16}$; the size of the bitmaps are equal in both AFL and Waffle.

\subsubsection*{wafl-llvm-pass.so.cc}

Next, we inject our instrumentation into the program. As mentioned in the previous chapter, this stage requires the LLVM modules to analyze and insert the instructions. First, we define the \textbf{visitors}:

\begin{lstlisting}[language=C++,style=CodeStyle,label={lst:wfl-vis}]
struct CountAllVisitor : public InstVisitor<CountAllVisitor> {
  unsigned Count;
  CountAllVisitor() : Count(0) {}
  void visitMemCpyInst(MemCpyInst &I) { ++Count;}
};
\end{lstlisting}

This way, we can count the number of memory copies in an execution. The \texttt{CountAll\-Visitor} structure keeps track of the instructions that LLVM considers them as memory copies.

Now we can insert our instructions to the basicblocks:

\lstinputlisting[language=C,style=CodeStyle,label={lst:llvm-pass},caption={LLVM-mode instrumentation pass}]{Codes/Chapter3/mini-wafl-llvm-pass.so.cc}

In Line 7, we locate the shared bitmap. Lines 16 loads the pointer to the bitmap and configures the meta data for storage \cite{nosanitize}.

Same as AFL, Waffle stores the counters in the \textbf{hashed value} of the path we explored (Listing \ref{lst:hash}). The usage of the coverage-guided hashed values, helps Waffle to collect coverage information, and at the same time, maximise the number of instructions in executions. The lines 21 to 23 loads the pointer to the appropriate location on the bitmap.

In each basicblock, the visitors look for the \textbf{copies}. In different executions, we noticed that the number of instructions increases so fast, and to control this number, we calculate its $\log$ (Lines 30-31):

\begin{equation}
  \label{eq:log}
  CNT = \log_{2}^{CAV} 
\end{equation}

Now that we have calculated \texttt{CNT}, we load the pointer on the bitmap and add \texttt{CNT} to the content of the pointer. Waffle stores the result of the addition in the same pointer. (Lines 36-39)

\subsubsection*{Applying the instrumentation}

