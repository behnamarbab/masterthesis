\section{Instrumentation}
\label{sec:3-instr}

\subsubsection*{waffle-llvm-rt.o.c}

We initialize the instrumentation with setting up the shared memory for Waffle (Listing \ref{lst:llvm-rt}):

\lstinputlisting[language=C,style=CodeStyle,label={lst:llvm-rt},caption={LLVM instrumentation bootstrap}]{Codes/Chapter3/waffle-llvm-rt.o.c}

\texttt{\_\_wafl\_area\_ptr} is the region that is allocated for counting the instructions, and is later shared when the instrumented program is running in fuzz testing.

The size of the bitmap \texttt{\_\_wafl\_icnt\_ptr} is equal to $ICNT\_SIZE=2^{16}$; the size of the bitmaps are equal in both AFL and Waffle.

\subsubsection*{wafl-llvm-pass.so.cc}

Next, we inject our instrumentation into the program. As mentioned in the previous chapter, this stage requires the LLVM modules to analyze and insert the instructions. First, we define the \textbf{visitors}:

\begin{lstlisting}[language=C++,style=CodeStyle,label={lst:wfl-vis}]
struct CountAllVisitor : public InstVisitor<CountAllVisitor> {
  unsigned Count;
  CountAllVisitor() : Count(0) {}
  void visitMemCpyInst(MemCpyInst &I) { ++Count;}
};
\end{lstlisting}

We count the number of memory copies in an execution. The \texttt{CountAll\-Visitor} structure keeps track of the instructions that LLVM considers them as memory copies.

Now we can insert our instructions to the basicblocks:

\lstinputlisting[language=C,style=CodeStyle,label={lst:llvm-pass},caption={LLVM-mode instrumentation pass}]{Codes/Chapter3/mini-wafl-llvm-pass.so.cc}

In Line 7, we locate the shared bitmap. Lines 16 loads the pointer to the bitmap and configures the meta-data for storage \cite{nosanitize}.

Same as AFL, Waffle stores the counters in the \textbf{hashed value} of the path we explored (Listing \ref{lst:hash}). The usage of the coverage-guided hashed values, helps Waffle to collect coverage information, and at the same time, maximise the number of instructions in executions. The lines 21 to 23 loads the pointer to the appropriate location on the bitmap.

In each basicblock, the visitors look for the \textbf{copies}. In different executions, we noticed that the number of instructions increases so fast, and to control this number, we calculate its $\log$ (Lines 30-31):

\begin{equation}
  \label{eq:log}
  CNT = \log_{2}^{CAV} 
\end{equation}

Now that we have calculated \texttt{CNT}, we load the pointer on the bitmap and add \texttt{CNT} to the content of the pointer. Waffle stores the result of the addition in the same pointer. (Lines 36-39)

Waffle applies these instrumentation in the compile time, and when the program is run, the instructions have to add a number which is pregenerated, into the shared memory.

\subsubsection*{Applying the instrumentation}

To compile the target program with the adjusted instrumentation, we replace the C/C++ compilers (clang/clang++) with \textbf{\texttt{wafl-clang}}. \say{This program is a drop-in replacement for clang, similar in most respects to ../afl-gcc. It tries to figure out compilation mode, adds a bunch of flags, and then calls the real compiler.} \cite{clang-fast} Except refactoring the filenames and the name of the variables, we did not apply any other modifications on \texttt{wafl-clang.c}.

Same as \ref{lst:gcc-sample}, we can start instrumentation by the command below:

\begin{lstlisting}[language=bash,style=CommandStyle,label={lst:wafl-clang}]
  ./wafl-clang sample_vul.c -o sample_vul_instr
\end{lstlisting}

Notice that we can insert compilation flags, such as \texttt{-fsanitize=address}, to enhance the performance of Waffle.
% Can I add the IR here?