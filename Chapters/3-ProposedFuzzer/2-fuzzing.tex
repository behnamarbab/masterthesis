\subsection{Fuzzing}
\label{sec:3-afl}

\input{Codes/Chapter3/waffle-fuzz/algorithm.tex}
\input{Codes/Chapter3/waffle-fuzz/mutate-alg.tex}
\input{Codes/Chapter3/waffle-fuzz/save_if_interesting-alg.tex}

% ! Define the favorable inputs in the background chapter - Reference the favorable test definition from before

Algorithm \ref{algo:waffle-fuzz} illustrates the fuzzing procedure in more details. Waffle processes the front queue's entry to check if the current input is bringing something new to the corpus. The front test case $T$ is first \textit{calibrated} to ensure that the input has been processed correctly. In the caliberation phase, the program is executed with $T$ as input, and the information such as execution time, length of the input file, and the EI-ORC of execution are collected. These values are then passed to the function \texttt{update\_bitmap\_score()} \ref{lst:update_bitmap_score} to evaluate and check if the test case is a favorable one. Each \texttt{queue\_entry} now contains three new variables for tracking the ORC of the program and find the most favorable cell (ORCC) of the ORC-array. A favorable input is either an indicator of a new code coverage, or it has an \textit{elite ORCC} which represents a new ORC for a path. 

\begin{definition}[Elite ORCC]
  An elite ORCC specifies the feature for which Waffle tries to maximize it. To minimize the memory space used in each \texttt{queue\_entry} and reduce the load in analyzing each entry, Waffle stores only one ORCC and ignores the rest of ORCCs. The selection of an elite ORCC is figured out in a function named \texttt{find\_elite()} \ref{lst:find_elite}. This function scans every non-zero ORCC and selects the elite ORCC based on one of these two conditions:
\end{definition}

\begin{enumerate}
  \item The ORCC is not tracked by Waffle before.
  \item The already tracked ORCC is increased with a higher ratio compared to other ORCCs.
\end{enumerate}

\lstinputlisting[language=C,style=CodeStyle,label={lst:find_elite},caption={Find elite}]{Codes/Chapter3/waffle-fuzz/find_elite.c}

\lstinputlisting[language=C,style=CodeStyle,label={lst:update_bitmap_score},caption={Update bitmap score}]{Codes/Chapter3/waffle-fuzz/update_bitmap_score.c}

Each newly generated input passes the caliberation phase, and as a result, it's favorablility is checked in this phase. In the fuzzing phase, after the caliberation is finished, Waffle calculates the \texttt{perf\_score} of the current entry. To increase the \texttt{perf\_score} of an entry, Waffle examines the \textbf{execution time}, \textbf{\texttt{bitmap\_size}}, and \textbf{TORC} of running the input (Listing \ref{lst:wcalc_score}).

\lstinputlisting[language=C,style=CodeStyle,label={lst:wcalc_score},caption={The modifications of Waffle in \texttt{calc\_score()}}]{Codes/Chapter3/waffle-fuzz/calculate_score.c}

The remaining parts of the transition from AFL's build to Waffles' applies the above modifications in \textbf{Instrumentation} and \textbf{Fuzzing} sections. These changes maintain the program-agnostic feature of AFL in whitebox fuzzing; the domain of the programs that Waffle can test stay as it was in AFL. To validate the above implementation on a real-world program, we choose QuickSort as the testing program.