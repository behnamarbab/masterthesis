\section{Start fuzzing}

Waffle takes the current entry from the queue, fuzzes it for a while, and when finished, turns back to the queue for another entry.

To use the instrumentation features, Waffle participates in sharing memory with the target program. The instantiated shared memory will be passed to the target program every time the fuzzer executes the program.

After the execution of the target program, collected data are stored in three arrays, $trace\_bits$, $perf\_bits$, and $icnt\_bits$. These arrays contain the information for coverage, stack memory consumption, and the counters for each basic block's instructions. The total size of the shared memory is 128KB.

Memlock calculates a \textit{stallness} for measuring the performance of the fuzzer. If the behavior of execution of input is too stall, Memlock skips fuzzing the current input entry and continues with the next entry of the queue. In Waffle, we do not intend to measure stallness, and we switch between fuzzing approaches, as mentioned before.

AFL trims the test-cases to increase the performance of coverage-finding techniques. As trimming the results may affect the target program's resource consumption, Memlock and Waffle disable this method in the fuzzing stage. 

Next, Waffle assesses its interest in considering the input as a favorable input. 

\begin{lstlisting}[language=C++,style=CodeStyle,caption={Update bitmap scores},label={lst:update_bitmap}]
  total_counts = 0;
  for (i = 0; i < ICNT_SIZE; i++) {
    if (icnt_bits[i]) {
      total_counts += icnt_bits[i];       
      if (top_rated[i]) {
        if (icnt_bits[i] < max_counts[i]) continue;
      }
      /* Insert ourselves as the new winner. */
      top_rated[i] = q;

      /* if we get here, we know that icnt_bits[i]==max_counts[i] */
      score_changed = 1;
    }
  }
  if(total_counts >= max_total_counts){
    top_rated[i] = q;
    score_changed = 1;
  } 
\end{lstlisting}

Here $ICNT\_SIZE$ is equal to the size of the bitmap for collecting the instruction counters. In case we find a new max for the number of instructions in a basic-block, we select the current input as the winner - favorable. [listing \ref{lst:update_bitmap}]

We are also selecting inputs with a total number of instructions more than any other input that was executed before.

\begin{lstlisting}[language=C++,style=CodeStyle,caption={Cull queue},label={lst:cull_queue}]
if (top_rated[i]) {
  /* if top rated for any i, will be favored */
  u8 was_favored_already = top_rated[i]->favored;

  top_rated[i]->favored = 1;

  /* increments counts only if not also favored for another i */
  if (!was_favored_already){
    queued_favored++;
    if (!top_rated[i]->was_fuzzed) pending_favored++;
  }
}

\end{lstlisting}

After collecting the execution features for an input, Waffle continues culling the queue and selects unique favorite inputs for the next generations. [listing \ref{lst:cull_queue}]

Notice that AFL and Memlock do the same method for selecting favorite inputs, except that they do not consider an overall execution feature, which Waffle knows as $max\_total\_counts$.